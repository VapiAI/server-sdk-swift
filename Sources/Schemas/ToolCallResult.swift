import Foundation

public struct ToolCallResult: Codable, Hashable, Sendable {
    /// This is the message that will be spoken to the user.
    /// 
    /// If this is not returned, assistant will speak:
    /// 1. a `request-complete` or `request-failed` message from `tool.messages`, if it exists
    /// 2. a response generated by the model, if not
    public let message: ToolCallResultMessage?
    /// This is the name of the function the model called.
    public let name: String
    /// This is the unique identifier for the tool call.
    public let toolCallId: String
    /// This is the result if the tool call was successful. This is added to the conversation history.
    /// 
    /// Further, if this is returned, assistant will speak:
    /// 1. the `message`, if it exists and is of type `request-complete`
    /// 2. a `request-complete` message from `tool.messages`, if it exists
    /// 3. a response generated by the model, if neither exist
    public let result: String?
    /// This is the error if the tool call was not successful. This is added to the conversation history.
    /// 
    /// Further, if this is returned, assistant will speak:
    /// 1. the `message`, if it exists and is of type `request-failed`
    /// 2. a `request-failed` message from `tool.messages`, if it exists
    /// 3. a response generated by the model, if neither exist
    public let error: String?
    /// This is optional metadata for the tool call result to be sent to the client.
    public let metadata: [String: JSONValue]?
    /// Additional properties that are not explicitly defined in the schema
    public let additionalProperties: [String: JSONValue]

    public init(
        message: ToolCallResultMessage? = nil,
        name: String,
        toolCallId: String,
        result: String? = nil,
        error: String? = nil,
        metadata: [String: JSONValue]? = nil,
        additionalProperties: [String: JSONValue] = .init()
    ) {
        self.message = message
        self.name = name
        self.toolCallId = toolCallId
        self.result = result
        self.error = error
        self.metadata = metadata
        self.additionalProperties = additionalProperties
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.message = try container.decodeIfPresent(ToolCallResultMessage.self, forKey: .message)
        self.name = try container.decode(String.self, forKey: .name)
        self.toolCallId = try container.decode(String.self, forKey: .toolCallId)
        self.result = try container.decodeIfPresent(String.self, forKey: .result)
        self.error = try container.decodeIfPresent(String.self, forKey: .error)
        self.metadata = try container.decodeIfPresent([String: JSONValue].self, forKey: .metadata)
        self.additionalProperties = try decoder.decodeAdditionalProperties(using: CodingKeys.self)
    }

    public func encode(to encoder: Encoder) throws -> Void {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try encoder.encodeAdditionalProperties(self.additionalProperties)
        try container.encodeIfPresent(self.message, forKey: .message)
        try container.encode(self.name, forKey: .name)
        try container.encode(self.toolCallId, forKey: .toolCallId)
        try container.encodeIfPresent(self.result, forKey: .result)
        try container.encodeIfPresent(self.error, forKey: .error)
        try container.encodeIfPresent(self.metadata, forKey: .metadata)
    }

    /// Keys for encoding/decoding struct properties.
    enum CodingKeys: String, CodingKey, CaseIterable {
        case message
        case name
        case toolCallId
        case result
        case error
        case metadata
    }
}