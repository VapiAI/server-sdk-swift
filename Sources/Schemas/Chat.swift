import Foundation

public struct Chat: Codable, Hashable, Sendable {
    /// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
    public let assistantId: String?
    /// This is the assistant that will be used for the chat. To use an existing assistant, use `assistantId` instead.
    public let assistant: CreateAssistantDto?
    /// These are the variable values that will be used to replace template variables in the assistant messages.
    /// Only variable substitution is supported in chat contexts - other assistant properties cannot be overridden.
    public let assistantOverrides: AssistantOverrides?
    /// This is the squad that will be used for the chat. To use a transient squad, use `squad` instead.
    public let squadId: String?
    /// This is the squad that will be used for the chat. To use an existing squad, use `squadId` instead.
    public let squad: CreateSquadDto?
    /// This is the name of the chat. This is just for your own reference.
    public let name: String?
    /// This is the ID of the session that will be used for the chat.
    /// Mutually exclusive with previousChatId.
    public let sessionId: String?
    /// This is the input text for the chat.
    /// Can be a string or an array of chat messages.
    public let input: ChatInput?
    /// This is a flag that determines whether the response should be streamed.
    /// When true, the response will be sent as chunks of text.
    public let stream: Bool?
    /// This is the ID of the chat that will be used as context for the new chat.
    /// The messages from the previous chat will be used as context.
    /// Mutually exclusive with sessionId.
    public let previousChatId: String?
    /// This is the unique identifier for the chat.
    public let id: String
    /// This is the unique identifier for the org that this chat belongs to.
    public let orgId: String
    /// This is an array of messages used as context for the chat.
    /// Used to provide message history for multi-turn conversations.
    public let messages: [ChatMessagesItem]?
    /// This is the output messages generated by the system in response to the input.
    public let output: [ChatOutputItem]?
    /// This is the ISO 8601 date-time string of when the chat was created.
    public let createdAt: Date
    /// This is the ISO 8601 date-time string of when the chat was last updated.
    public let updatedAt: Date
    /// These are the costs of individual components of the chat in USD.
    public let costs: [ChatCostsItem]?
    /// This is the cost of the chat in USD.
    public let cost: Double?
    /// Additional properties that are not explicitly defined in the schema
    public let additionalProperties: [String: JSONValue]

    public init(
        assistantId: String? = nil,
        assistant: CreateAssistantDto? = nil,
        assistantOverrides: AssistantOverrides? = nil,
        squadId: String? = nil,
        squad: CreateSquadDto? = nil,
        name: String? = nil,
        sessionId: String? = nil,
        input: ChatInput? = nil,
        stream: Bool? = nil,
        previousChatId: String? = nil,
        id: String,
        orgId: String,
        messages: [ChatMessagesItem]? = nil,
        output: [ChatOutputItem]? = nil,
        createdAt: Date,
        updatedAt: Date,
        costs: [ChatCostsItem]? = nil,
        cost: Double? = nil,
        additionalProperties: [String: JSONValue] = .init()
    ) {
        self.assistantId = assistantId
        self.assistant = assistant
        self.assistantOverrides = assistantOverrides
        self.squadId = squadId
        self.squad = squad
        self.name = name
        self.sessionId = sessionId
        self.input = input
        self.stream = stream
        self.previousChatId = previousChatId
        self.id = id
        self.orgId = orgId
        self.messages = messages
        self.output = output
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.costs = costs
        self.cost = cost
        self.additionalProperties = additionalProperties
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.assistantId = try container.decodeIfPresent(String.self, forKey: .assistantId)
        self.assistant = try container.decodeIfPresent(CreateAssistantDto.self, forKey: .assistant)
        self.assistantOverrides = try container.decodeIfPresent(AssistantOverrides.self, forKey: .assistantOverrides)
        self.squadId = try container.decodeIfPresent(String.self, forKey: .squadId)
        self.squad = try container.decodeIfPresent(CreateSquadDto.self, forKey: .squad)
        self.name = try container.decodeIfPresent(String.self, forKey: .name)
        self.sessionId = try container.decodeIfPresent(String.self, forKey: .sessionId)
        self.input = try container.decodeIfPresent(ChatInput.self, forKey: .input)
        self.stream = try container.decodeIfPresent(Bool.self, forKey: .stream)
        self.previousChatId = try container.decodeIfPresent(String.self, forKey: .previousChatId)
        self.id = try container.decode(String.self, forKey: .id)
        self.orgId = try container.decode(String.self, forKey: .orgId)
        self.messages = try container.decodeIfPresent([ChatMessagesItem].self, forKey: .messages)
        self.output = try container.decodeIfPresent([ChatOutputItem].self, forKey: .output)
        self.createdAt = try container.decode(Date.self, forKey: .createdAt)
        self.updatedAt = try container.decode(Date.self, forKey: .updatedAt)
        self.costs = try container.decodeIfPresent([ChatCostsItem].self, forKey: .costs)
        self.cost = try container.decodeIfPresent(Double.self, forKey: .cost)
        self.additionalProperties = try decoder.decodeAdditionalProperties(using: CodingKeys.self)
    }

    public func encode(to encoder: Encoder) throws -> Void {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try encoder.encodeAdditionalProperties(self.additionalProperties)
        try container.encodeIfPresent(self.assistantId, forKey: .assistantId)
        try container.encodeIfPresent(self.assistant, forKey: .assistant)
        try container.encodeIfPresent(self.assistantOverrides, forKey: .assistantOverrides)
        try container.encodeIfPresent(self.squadId, forKey: .squadId)
        try container.encodeIfPresent(self.squad, forKey: .squad)
        try container.encodeIfPresent(self.name, forKey: .name)
        try container.encodeIfPresent(self.sessionId, forKey: .sessionId)
        try container.encodeIfPresent(self.input, forKey: .input)
        try container.encodeIfPresent(self.stream, forKey: .stream)
        try container.encodeIfPresent(self.previousChatId, forKey: .previousChatId)
        try container.encode(self.id, forKey: .id)
        try container.encode(self.orgId, forKey: .orgId)
        try container.encodeIfPresent(self.messages, forKey: .messages)
        try container.encodeIfPresent(self.output, forKey: .output)
        try container.encode(self.createdAt, forKey: .createdAt)
        try container.encode(self.updatedAt, forKey: .updatedAt)
        try container.encodeIfPresent(self.costs, forKey: .costs)
        try container.encodeIfPresent(self.cost, forKey: .cost)
    }

    /// Keys for encoding/decoding struct properties.
    enum CodingKeys: String, CodingKey, CaseIterable {
        case assistantId
        case assistant
        case assistantOverrides
        case squadId
        case squad
        case name
        case sessionId
        case input
        case stream
        case previousChatId
        case id
        case orgId
        case messages
        case output
        case createdAt
        case updatedAt
        case costs
        case cost
    }
}